---
title: "tinkering"
format: html
---

```{r, include=FALSE, echo=FALSE, message=FALSE, warning=FALSE}
packages <- c("ggplot2", "haven", "dplyr", "tidycensus", "readr")

for (pkg in packages) {
  if (!require(pkg, character.only = TRUE, quietly = TRUE)) {
    install.packages(pkg, repos = "https://cran.rstudio.com/")
    library(pkg, character.only = TRUE)
  }
}

options(scipen = 10)
```

```{r}
df <- readr::read_csv("../data/poverty_data.csv.gz")

# This code is used to get the actual state from the FIPs code
fips_to_state <- tidycensus::fips_codes %>%
    select("state", "state_code") %>%
    distinct() %>%
    mutate(state_code = as.numeric(state_code))

df <- df %>%
    rename(state_code = st) %>%
    left_join(fips_to_state, join_by(state_code))


# This is just to get the labels for the various categorical codes in the original dataset
# This information can be found in spm-asc-data-dictionary.pdf
df <- df %>%
    mutate(
        education = factor(education, levels=0:4, labels=c(NA, "Less than a HS degree", "HS degree", "Some college", "College degree")),
        sex = factor(sex, levels = 1:2, labels = c("male", "female")),
        race = factor(race, levels = 1:4, labels = c("white", "black", "asian", "other")),
        mar = factor(mar, levels = 1:5, labels = c("married", "widowed", "divorced", "separated", "never married"))
    )
```

# Regions

```{r}
# Define vectors for each census region
northeast_states <- c("CT", "ME", "MA", "NH", "RI", "VT", "NJ", "NY", "PA")
midwest_states   <- c("IL", "IN", "MI", "OH", "WI", "IA", "KS", "MN", "MO", "NE", "ND", "SD")
south_states     <- c("DE", "FL", "GA", "MD", "NC", "SC", "VA", "DC", "WV", "AL", "KY", "MS", "TN", "AR", "LA", "OK", "TX")
west_states      <- c("AZ", "CO", "ID", "MT", "NV", "NM", "UT", "WY", "AK", "CA", "HI", "OR", "WA")

# Map state abbreviations to regions
df <- df %>%
  mutate(region = case_when(
    state %in% northeast_states ~ "Northeast",
    state %in% midwest_states   ~ "Midwest",
    state %in% south_states     ~ "South",
    state %in% west_states      ~ "West",
    TRUE ~ NA_character_
  ))
```

```{r}
ggplot(df, aes(x=region)) +
    geom_bar()
```


# Learning how to do stratified sampling

Stratify on race as a simple example

```{r}
sample <- df %>%
    group_by(race) %>%
    slice_sample(prop=0.2) # takes 1*prop of the rows.

sample$race %>% table() / nrow(sample)
```

```{r}
df$race %>% table() / nrow(df)
```

wow. okay. that's easy.

## More complex stratification

```{r}
cat_columns <- c("hispanic", "spm_poor", "mar", "sex", "education", "race", "region")
sample <- df %>%
    group_by(
        across(
            all_of(cat_columns)
        )
    ) %>%
    slice_sample(prop=0.2) %>%
    ungroup()
```

```{r}
# This code was generated by chatgpt. It's just for easily looking at proportions, nothing going into the report
# So I feel okay offloading that labor onto the stupid ai chatbot
for (col in cat_columns) {
  cat("\n", col, "\n", sep = "")
  
  # Compute proportions and convert to data frames
  prop_df <- as.data.frame(prop.table(table(df[[col]])))
  prop_sample <- as.data.frame(prop.table(table(sample[[col]])))
  
  # Name the columns clearly
  colnames(prop_df) <- c("value", "prop_df")
  colnames(prop_sample) <- c("value", "prop_sample")
  
  # Merge them
  comparison <- merge(prop_df, prop_sample, by = "value", all = TRUE)
  
  # Round only numeric columns
  comparison[, c("prop_df", "prop_sample")] <- round(comparison[, c("prop_df", "prop_sample")], 3)
  
  print(comparison)
}
```

Alright, this seems to work. We can use this to create a stratified sample! 

No sense in saving a new dataframe though. We'll set a seed in the final notebook and tinker w/ sample sizes in the modeling step. 